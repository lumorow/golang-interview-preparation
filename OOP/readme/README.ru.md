# Объектно-ориентированное программирование в golang

<h1 align="center"><img class="goldT" src="../../img/oopgo.jpeg" ></h1>

## Разница между new и make
`make`  выделяет память для ссылочных типов данных ( slice , map , chan ), а также инициализирует
их базовые структуры данных.  

`new` возвращает только указатели на инициализированную память и устанавливает для нее нулевое значение для типа `T`, 
то есть `0` для `int`, `''` для `string` и `nil` для ссылочных типов (`slice`, `map`, `chan`)

## Класс. Создание объекта класса

В golang так таков классов нет, но используются структуры. У структур также имеются поля и методы, можно написать
свой конструктор, но он будет представляться как обычный метод.

```golang
type person struct {
    age    int
    height int
    weight int
    male   string
    name   string
}

func NewPerson(age, height, weight int, male, name string) *person {
    return &person{
    age:    age,
    height: height,
    weight: weight,
    male:   male,
    name:   name,
    }
}
```

## Видимость структуры и полей
В `Go` используется правило регистра первой буквы имени — если название начинается заглавной буквы —
это `public`-доступ, если со строчной — `private`.  
Из примера выше можем увидеть, что структура `person` у нас не экспортируемая (приватная),
поэтому она доступна только в данном пакете, где мы ее инициализировали. Но мы создали конструктор,
который может нам создать этот объект по заданной инструкции внутри него.

## Реализация концепций в golang:
### Наследование

В golang нет наследования, а используется `встраивание`.  
Самый простой случай использования наследования — дочерний тип должен иметь доступ к полям и методам родительского типа.
Это делается в Go посредством встраивания. Базовая структура встраивается в дочернюю, после чего базовые поля
и методы могут быть напрямую доступы дочерней структуре.

Подробнее:  
[ООП: Наследование в Golang](https://github.com/MaksimDzhangirov/oop-go/blob/master/docs/inheritance.md)

### Полиморфизм
#### Полиморфизм во время компиляции (Compile Time Polymorphism) - невозможен в golang

При полиморфизме во время компиляции какую функцию вызывать решает компилятор.  
Примерами полиморфизма во время компиляции могут быть:
- перегрузка метода/функции: существует более одного метода/функции с одним и тем же именем,
но с разными сигнатурами или, возможно, с разными типами возвращаемых значений;  
- перегрузка операторов: один и тот же оператор используется для работы с разными типами данных.

Go не поддерживает перегрузку метода.  
Go также не поддерживает перегрузку оператора.
***
#### Полиморфизм во время выполнения (Run Time Polymorphism) - достигается за счет интерфейсов

Полиморфизм во время выполнения означает, что решение о том какую функцию вызывать принимается во время выполнения.  
В [oop.go](https://github.com/lumorow/golang-interview-preparation/blob/main/OOP/oop.go) `interface Grower` создает контракт с
`person` и `dog` структурами, которые имеют разную реализацию функции `growUp()`.

Подробнее:  
[ООП: Полиморфизм в Golang](https://github.com/MaksimDzhangirov/oop-go/blob/master/docs/polymorphism.md)

### Абстрактные классы

Интерфейс в Go не содержит полей, а также не позволяет определять методы внутри него. Любой тип должен реализовывать все методы интерфейса, чтобы иметь тип этого интерфейса. Существуют ситуации, когда полезно иметь реализацию метода по умолчанию, а также поля по умолчанию в Go. Прежде чем понять как это можно сделать давайте сначала разберёмся с требованиями для абстрактного класса:

Абстрактный класс должен иметь поля по умолчанию
Абстрактный класс должен иметь метод по умолчанию
Не должно быть возможности непосредственно создать экземпляр абстрактного класса

Подробнее:  
[ООП: Абстрактный класс в Golang](https://github.com/MaksimDzhangirov/oop-go/blob/master/docs/abstract_class.md)

### Инкапсуляция

Golang обеспечивает инкапсуляцию на уровне пакета. В Go нет ключевых слов public, private или protected. Единственный механизм управления видимостью — использование прописных и строчных букв.

Идентификаторы с прописной буквы экспортируются. Прописная буква означает, что это экспортируемый идентификатор.
Идентификаторы со строчной буквы не экспортируются. Строчные буквы указывают на то, что идентификатор не экспортируется и будет доступен только из того же пакета.
Существует пять видов идентификаторов, которые можно экспортировать.

- Структура
- Метод структуры
- Поле структуры
- Функция
- Переменная

Подробнее:  
[ООП: Инкапсуляция в Golang](https://github.com/MaksimDzhangirov/oop-go/blob/master/docs/encapsulation.md)

## Дополнительный материал

- [Объектно-ориентированное программирование в Golang](https://medium.com/nuances-of-programming/%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-golang-52f36f2fa837)

## README.md

- eng [English](https://github.com/lumorow/golang-interview-preparation/blob/main/OOP/README.md)
- ru [Русский](https://github.com/lumorow/golang-interview-preparation/blob/main/OOP/readme/README.ru.md)