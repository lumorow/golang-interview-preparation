# Паттерны проектирования

<h1 align="center"><img class="goldT" src="../../img/patterns.webp" ></h1>

Можно перейти сразу на объяснение и реализацию паттернов:
[Паттерны проектирования с примерами на Golang](https://github.com/AlexanderGrom/go-patterns)


## Порождающие.
***
Такие шаблоны нужны, чтобы оптимизировать создание того или иного объекта.
Порождающие паттерны помогают создавать объекты так, чтобы они эффективно общались с другими, и управлять их работой.

### Вот несколько примеров:
«Фабрика» (Factory) — для создания новых объектов придумывают отдельный класс. Он создает объекты как копии некоего эталона;  
«Прототип» (Prototype) — объект сам создает свои копии;  
«Строитель» (Builder) — похож на фабрику, но новые объекты можно модифицировать. Они создаются по сложной логике, а не копируют эталонный;  
«Одиночка» (Singleton) — подразумевает наличие одного большого объекта, который имеет глобальный доступ ко всему;  
«Ленивая инициализация» (Lazy Initialization) — метод, при котором объект инициализируется не сразу, а по мере

Существуют и другие шаблоны разной сложности. Для каждой задачи оптимальнее тот или иной паттерн. Конкретное решение зависит от задачи, но в результате должна получиться эффективная и оптимизированная система.

## Структурные.
***
Если порождающие паттерны отвечают за создание и взаимодействие объектов, то структурные — за то, как эти объекты структурированы в коде.
Они описывают, каким образом простые классы и объекты «собираются» в более сложные.

### Вот примеры:

«Декоратор» (Decorator) — шаблон для подключения дополнительного поведения к объекту;  
«Компоновщик» (Composite) — паттерн, который объединяет несколько объектов в древовидную структуру;  
«Мост» (Bridge) — принцип разделения сущности на абстракцию и реализацию, чтобы теоретическая структура и конкретный объект могли изменяться независимо;  
«Фасад» (Facade) — метод для сведения внешних вызовов к одному объекту;  
«Заместитель» (Proxy) — паттерн, похожий на «Фасад», но со специальным объектом-заместителем, который контролирует доступ к основному.
Это только некоторые примеры. Реальных паттернов намного больше.

## Поведенческие.
***
Это паттерны проектирования, которые описывают, как объекты себя ведут и взаимодействуют с другими.
Их используют, например, для разделения обязанностей между разными сущностями или для реагирования
на изменения без ошибок.

### Примеры поведенческих паттернов:

«Итератор» (Iterator) — один объект последовательно дает доступ к разным другим, при этом не использует их сложные описания;  
«Наблюдатель» (Observer) – шаблон, при котором объекты узнают об изменениях в других;  
«Хранитель» (Memento) — помогает сохранить объект в каком-то состоянии с возможностью вернуться к нему в будущем;  
«Цепочка ответственности» (Chain of Responsibility) — распределяет ответственность за те или иные задачи на разные объекты;  
«Посредник» (Mediator) — организует слабые связи между объектами, чтобы снизить их зависимость друг от друга.  
Как понять, какой паттерн применить  
У каждого паттерна своя область использования. Опытные разработчики понимают, где что использовать, по самой специфике задачи,
но в начале пути это может быть сложно.

### Выбор паттерна на более мелкие шаги:

- выделить сущности, которые используются в процессе;
- продумать связи между ними;
- абстрагировать получившуюся систему от конкретной задачи;
- посмотреть, не подходит ли проблема по смыслу на что-то, для чего есть паттерн;
- выбрать несколько паттернов из нужной группы и посмотреть какой подходит лучше;
- продумать конкретную реализацию этого паттерна с учетом особенностей задачи.

- Это выглядит сложно, но со временем придет привычка. Опытные разработчики уже «набили руку», поэтому проблемы с выбором паттерна у них возникают намного реже. Когда сформируется понимание и наберется практика, будет проще.

### Преимущества паттернов проектирования
- Ускоряют и облегчают написание кода.
- Позволяют не «изобретать велосипед», а воспользоваться готовым проверенным принципом.
- При грамотном использовании делают код более читаемым и эффективным.
- Упрощают взаимопонимание между разработчиками.
- Помогают избавиться от типовых ошибок.
- Не зависят от языка программирования и его особенностей.
- Позволяют реализовывать сложные задачи быстрее и проще.

### Недостатки паттернов проектирования
- Использование паттернов ради паттернов, наоборот, усложняет код и запутывает разработчиков.
- Неправильное применение того или иного шаблона способно сделать программу менее эффективной.
- Паттерны не универсальны: в одной задаче конкретный паттерн подойдет, в другой нет.
- На ранних этапах изучения бывает сложно выбрать подходящий для конкретной проблемы паттерн.
- Из-за сильной связи с объектно-ориентированным программированием использование паттернов в других парадигмах ограничено. Хотя, например, в функциональном программировании они могут применяться — просто реализуются иначе.

### Стоит ли пользоваться паттернами
Наличие недостатков не делает саму идею паттернов плохой. Просто это инструмент, которым нужно пользоваться с умом.
Не стоит применять шаблоны там, где можно без них обойтись, просто ради «красоты». Если же использовать их в местах,
где они действительно нужны – они станут хорошей помощью в работе программиста.

## Дополнительный материал
***
- [Go Design patterns (Introduction)](https://medium.com/@mr_apr/go-design-patterns-introduction-9c5e57a3cb13)
- [Паттерны проектирования с примерами на Golang](https://github.com/AlexanderGrom/go-patterns)
- [Golang | Паттерны проектирования - Агентство цифровых технологий](https://www.youtube.com/playlist?list=PLxj7Nz8YYkVW5KHnsb9qWUDP2eD1TXl1N)

## README.md
***
- eng [English](https://github.com/lumorow/golang-interview-preparation/blob/main/Patterns/README.md)
- ru [Русский](https://github.com/lumorow/golang-interview-preparation/blob/main/Patterns/readme/README.ru.md)